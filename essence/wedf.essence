language ESSENCE' 1.0

$ Size of group
given n: int

$ Number of sets
given setnum: int(1..n)

$ Size of each set
given setsizes: matrix indexed [int(1..setnum)] of int(1..n)

$ Size of largest set
given maxsetsize: int(1..n)

$ Occurrences of each value
given lambda : int(1..n)

given makeEDF: bool
given makeSEDF: bool

where (makeEDF \/ makeSEDF)
where !(makeEDF /\ makeSEDF)

$ Inverse of group
given inverses: matrix indexed by [int(1..n)] of int(1..n)

$ Multiplication table, as table and tuples
given multable: matrix indexed by [int(1..n), int(1..n)] of int(1..n)
given multuples: matrix indexed by [int(1..n*n), int(1..3)] of int(1..n)

$ x*y^-1, as table and tuples
given mulinvtable: matrix indexed by [int(1..n), int(1..n)] of int(1..n)
given mulinvtuples: matrix indexed by [int(1..n*n), int(1..3)] of int(1..n)

$ The EDF, expressed as a list of lists
find edf: matrix indexed by [int(1..setnum), int(1..maxsetsize)] of int(1..n)


find weights: matrix indexed by [int(1..setsize), int(1..2)] of int

$ Extra variables, to represent the values of x*y^-1, for every pairing
find edfmap: matrix indexed by [int(1..setnum), int(1..maxsetsize), int(1..setnum), int(1..maxsetsize)] of int(1..n)

$ N_i(delta) for each value d
find weightcount: matrix indexed by [int(1..setnum), int(1..n)] of int

such that

$ Set the stub values so the WEDFs can be different sizes
forAll i : int(1..setnum). forAll j : int((setsizes[i]+1)..maxsetsize). edf[i][j] = 0,

$ No value is repreated in any set of the EDF (except the 0 stub values for sets of different size)
allDiff([x | x <- flatten(edf) /\ x != 0]),

$ Now set up the 'edfmap', this makes a variable 'edfmap[p1,p2,q1,q2]'
$ which is equal to x*y^-1, where x is the p2th element of the p1st set
$ and y is the q2th element of the q1th set
forAll p1 : int(1..setnum). forAll q1 : int(1..setnum).
(
    (    forAll p2 : int(1..maxsetsize). forAll q2 : int(1..maxsetsize).
        table([edf[p1,p2],edf[q1,q2],edfmap[p1,p2,q1,q2]], mulinvtuples)
    )
),

$ Set up the weightcount
forAll p1 : int(1..setnum). forAll v : int(1..n). 
    weightcount[p1,v] = weight[p1, 1] / weight[p1, 2] * size(edfmap[p1,p2,q1,q2] 
        | p2 : int(1..maxsetsize), q2 : int(1..setsize), q1 : int(1..maxsetsize), 
          p1 != q1, edf[p1, p2] != 0, edf[q1, q2] != 0, p1=v]),


forAll v : int(1..n).
    sum([weightcount])
$ gcc(
$     [edfmap[p1,p2,q1,q2] 
$         | p1 : int(1..setnum), p2 : int(1..maxsetsize), q2 : int(1..setsize), q1 : int(1..maxsetsize), 
$             p1 != q1, edf[p1, p2] != 0, edf[q1, q2] != 0], $ignore the 0 values

$     [i | i : int(1..n)], [toInt(i != 1)*dups | i : int(1..n)]
$ )

